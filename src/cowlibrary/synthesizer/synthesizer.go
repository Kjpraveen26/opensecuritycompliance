package synthesizer

import (
	"encoding/json"
	"errors"
	"fmt"
	"net/http"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/briandowns/spinner"
	"github.com/go-resty/resty/v2"
	"github.com/iancoleman/strcase"
	"github.com/kyokomi/emoji"

	"cowlibrary/constants"
	"cowlibrary/utils"
	"cowlibrary/vo"
)

func InitSynthesizer(synthesizerName, path string, additionalInfo *vo.AdditionalInfo) (string, error) {
	if utils.IsEmpty(path) {
		if additionalInfo != nil {
			path = additionalInfo.PolicyCowConfig.PathConfiguration.SynthesizersPath
		}
	}
	synthesizerName = strcase.ToCamel(synthesizerName)
	synthesizerClassName := utils.GetSynthesizerClassName(synthesizerName)

	synthesizerName = utils.GetValidSynthesizerName(synthesizerName)
	synthesizerPath, err := utils.GetSynthesizerPath(path, synthesizerName)
	if err != nil {
		return "", errors.New("not a valid path")
	}
	_, err = os.Stat(synthesizerPath)
	if os.IsNotExist(err) {
		if err := os.MkdirAll(synthesizerPath, os.ModePerm); err != nil {
			return "", errors.New("not a valid path")
		}
	}

	defaultCode := constants.SynthesizerAutoGeneratedDefaultCode

	defaultCode = strings.ReplaceAll(defaultCode, "{{SynthesizerName}}", synthesizerClassName)

	err = os.WriteFile(filepath.Join(synthesizerPath, fmt.Sprintf("%s.py", synthesizerName)), []byte(defaultCode), os.ModePerm)
	if err != nil {
		return "", err
	}

	return synthesizerPath, nil
}

func ExportSynthesizer(synthesizerName, synthesizersPath string, additionalInfo *vo.AdditionalInfo) (exportedData *vo.ExportedData, err error) {
	synthesizerPath := ``

	if utils.IsNotEmpty(synthesizerName) && utils.IsNotEmpty(synthesizersPath) {
		synthesizerPath = filepath.Join(synthesizersPath, synthesizerName)
	}

	if utils.IsEmpty(synthesizerPath) {
		if additionalInfo != nil {
			synthesizerPath = utils.GetSynthesizerPathFromCatalog(additionalInfo, "", synthesizerName)
		}
	}

	synthesizerName = utils.GetValidSynthesizerName(synthesizerName)

	if utils.IsFolderNotExist(synthesizerPath) {
		return nil, fmt.Errorf("%s not a valid synthesizer path", synthesizerPath)
	}

	if utils.IsEmpty(additionalInfo.DownloadsPath) {

		additionalInfo.DownloadsPath = additionalInfo.PolicyCowConfig.PathConfiguration.DownloadsPath

	}
	if additionalInfo.ExportFileType == "tar" {

		err = utils.TARFiles(synthesizerPath, additionalInfo.DownloadsPath, synthesizerName)
	} else {

		err = utils.ZIPFilesWithCommands(synthesizersPath, additionalInfo.DownloadsPath, synthesizerName)
	}

	if err != nil {
		return exportedData, err
	}

	exportedData = &vo.ExportedData{FilePath: filepath.Join(additionalInfo.DownloadsPath, synthesizerName)}

	return exportedData, err

}

func PublishSynthesizer(synthesizerName, path string, additionalInfo *vo.AdditionalInfo) error {

	exportedData, err := ExportSynthesizer(synthesizerName, path, additionalInfo)
	if err != nil {
		return err
	}
	compressedFilePath := exportedData.FilePath

	if !strings.HasSuffix(compressedFilePath, "zip") && !strings.HasSuffix(compressedFilePath, "tar") {
		if utils.IsNotEmpty(additionalInfo.ExportFileType) {
			compressedFilePath += "." + additionalInfo.ExportFileType
		} else {
			compressedFilePath += ".zip"
		}
	}

	if utils.IsFileNotExist(compressedFilePath) {
		return errors.New("file not exist")
	}

	headerMap, err := utils.GetAuthHeader(additionalInfo)
	if err != nil {
		return err
	}
	client := resty.New()

	url := fmt.Sprintf("%s/v1/workflow-instances", utils.GetCowAPIEndpoint(additionalInfo))

	byts, err := os.ReadFile(compressedFilePath)
	if err != nil {
		return err
	}

	defer os.Remove(compressedFilePath)

	s := spinner.New(spinner.CharSets[38], 100*time.Millisecond) // Build our new spinner
	s.Prefix = "Publishing ..."
	s.Start()

	type result struct {
		ID string `json:"id,omitempty"`
	}
	resultData := &result{}
	errorData := json.RawMessage{}

	synthesizerPublisher := &vo.SynthesizerPublisherVO{WorkflowConfigName: "Upload synthesizer card"}
	synthesizerPublisher.Input = additionalInfo.SynthesizerVO
	synthesizerPublisher.Input.FileBytes = byts
	synthesizerPublisher.Input.Level = "user"
	synthesizerPublisher.Input.Name = additionalInfo.SynthesizerVO.Name

	resp, err := client.R().SetHeaders(headerMap).SetBody(synthesizerPublisher).SetResult(resultData).SetError(&errorData).Post(url)

	if err != nil {
		return err
	}

	if resp.StatusCode() != http.StatusCreated {
		return errors.New("cannot publish the synthesizer")
	}

	s.Stop()

	if len(errorData) > 4 {
		return errors.New(string(errorData))
	}

	emoji.Println(":megaphone: Synthesizer has been published!!! :party_popper::partying_face::party_popper:")

	synthesizerCatalogURL := fmt.Sprintf("%s/ui/synthesizer-workflow", utils.GetCowDomain(additionalInfo))

	fmt.Println(utils.ColorLink("You can view the published synthesizer in the synthesizers catalog.", synthesizerCatalogURL, "italic green"))

	return nil
}

func GetAvailableSynthesizers(synthesizerName string, additionalInfo *vo.AdditionalInfo) ([]*vo.Synthesizer, error) {
	synthesizers := make([]*vo.Synthesizer, 0)
	collection := &vo.Collection{Items: &synthesizers}
	errorData := json.RawMessage{}

	headerMap, err := utils.GetAuthHeader(additionalInfo)
	if err != nil {
		return nil, err
	}
	client := resty.New()

	if utils.IsNotEmpty(synthesizerName) {
		additionalInfo.SynthesizerVO.Name = synthesizerName
	}

	packageName := utils.GetValidSynthesizerName(additionalInfo.SynthesizerVO.Name)

	url := fmt.Sprintf("%s/v2/synthesizer-card", utils.GetCowAPIEndpoint(additionalInfo))

	resp, err := client.R().SetHeaders(headerMap).SetQueryParams(map[string]string{
		"packageName": packageName,
		"status":      "active,approval waiting",
	}).SetResult(collection).SetError(&errorData).Get(url)

	if resp.StatusCode() != http.StatusOK {
		return nil, errors.New("cannot fetch the synthesizers")
	}

	return synthesizers, err

}

func IsSynthesizerAlreadyPresent(synthesizerName string, additionalInfo *vo.AdditionalInfo) (bool, error) {
	synthesizers, err := GetAvailableSynthesizers(synthesizerName, additionalInfo)
	if err != nil {
		return false, err
	}
	return len(synthesizers) > 0, nil
}
